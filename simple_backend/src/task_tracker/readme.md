минус хранения состояния в оперативной памяти в том, что данные теряются при перезапуске программы
после исправления данные сохраняются в файле tasks.json и не исчезают при перезапуске

мы не избавились от хранения состояния, а изменили способ реализации с хранения в оперативной памяти на хранение в файле json

где можно хранить состояние:
оперативная память +легко реализовать -данные теряются при перезапуске
текстовый файл/жсон +легко реализовать -не подходит для большого объема данных
БД +надежно, большой функционал -нужен сервер
Кэш +быстро -данные могут быть удалены при достижении лимита памяти

В контексте данного проекта состояние гонки может возникнуть, если:
Два пользователя одновременно обращаются к API для изменения списка задач.
Один запрос читает задачи через load_tasks, а другой в это время их обновляет (save_tasks).
Первый запрос завершает операцию на устаревших данных, что приводит к потере изменений второго запроса.

Возможное решение проблемы:

Обновление через версионность данных
Jsonbin.io поддерживает версионность через хэдер X-Version-Match.
При записи данных указывается версия ресурса (например, текущая версия данных). Если версия изменится к моменту записи (т.е. другой клиент изменил данные), запись будет отклонена.

Минус в том, что версионность только в платной версии

Можно еще использовать временные метки
Нужно внедрить следующую логику:

Добавление временной метки:

При загрузке данных из jsonbin.io сохранять текущую временную метку (например, из заголовков ответа или специального поля JSON).
При сохранении данных проверять, совпадает ли временная метка с той, что была загружена.
Проверка изменения данных:

Если временная метка изменилась с момента последнего чтения, значит, данные были обновлены другим клиентом, и необходимо загрузить их заново перед применением изменений.
